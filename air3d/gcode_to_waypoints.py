import sys
import os
import numpy as np
import pickle

'''
Generates timestamped position and velocity waypoints
from gcode file generated by the mandoline slicer

gcode units:
    - Length [mm]
    - Feed rate [mm/min]

waypoint units - SI [m], [s]
'''

def parse_gcode_line(line):
    line = line.split(';')[0]   # Reads until a semicolon
    line = line.split('(')[0]   # Reads until a opening bracket
    ### TODO: Add comment parser? (currently just ignoring comments)
    if not line:
        return None # Line was empty
    
    # Whatever is left should start with G or M
    if line[0]=='G':
        return parse_G_line(line[1:])
    elif line[0]=='M':
        return parse_M_line(line[1:])
    else:
        return None # Cannot parse line ???

def parse_G_line(g_string):
    move_type = None
    x_val = None
    y_val = None
    z_val = None
    f_val = None
    e_val = None
    to_parse = g_string.split(' ')
    while ("" in to_parse):
        to_parse.remove("") # Remove empty strings
    move_type = int(to_parse.pop(0))
    if move_type==0:    # Rapid move
        for i in range(len(to_parse)):
            if to_parse[i][0]=='X':     # x-coordinate [m]
                x_val = float(to_parse[i][1:])/1e3
            elif to_parse[i][0]=='Y':   # y-coordinate [m]
                y_val = float(to_parse[i][1:])/1e3
            elif to_parse[i][0]=='Z':   # z-coordinate [m]
                z_val = float(to_parse[i][1:])/1e3
            elif to_parse[i][0]=='F':   # feed rate [m/s]
                f_val = float(to_parse[i][1:])/6e4
    elif move_type==1:    # Linear move
        for i in range(len(to_parse)):
            if to_parse[i][0]=='X':     # x-coordinate [m]
                x_val = float(to_parse[i][1:])/1e3
            elif to_parse[i][0]=='Y':   # y-coordinate [m]
                y_val = float(to_parse[i][1:])/1e3
            elif to_parse[i][0]=='Z':   # z-coordinate [m]
                z_val = float(to_parse[i][1:])/1e3
            elif to_parse[i][0]=='F':   # feed rate [m/s]
                f_val = float(to_parse[i][1:])/6e4
            elif to_parse[i][0]=='E':   # cumulative extruded value [m]
                e_val = float(to_parse[i][1:])/1e3
    elif move_type==2 or move_type==3:    # Circular arc
        ### TODO: circular arcs
        arcDir = None
        # Note: The slicer only commands G0 and G1 so we are set :)
    else:
        return None # Cannot parse line
    return [move_type, [x_val, y_val, z_val], f_val, e_val]

def parse_M_line(m_string):
    return None

def parsed_line_to_waypoint(parsed_line, previous_waypoint):
    waypoint = np.zeros((7,),dtype=np.float64)
    if len(previous_waypoint):  # TODO: Caution! This might cause weird effects
        position_coords = parsed_line.pop(0)
        if position_coords[0] is not None:
            waypoint[1] = position_coords[0]
        else:
            waypoint[1] = previous_waypoint[1]
        if position_coords[1] is not None:
            waypoint[2] = position_coords[1]
        else:
            waypoint[2] = previous_waypoint[2]
        if position_coords[2] is not None:
            waypoint[3] = position_coords[2]
        else:
            waypoint[3] = previous_waypoint[3]
        delta_pos = waypoint[1:4] - previous_waypoint[1:4]
        delta_pos_norm = np.linalg.norm(delta_pos)
        feed_rate = parsed_line.pop(0)
        ### TODO: accomodate delta_t due to extruder time
        delta_t = delta_pos_norm / feed_rate    # Move time
        waypoint[0] = previous_waypoint[0] + delta_t    # Time stamp
        if delta_t < 1e-8:
            waypoint[4:] = np.zeros((3,))
        else:
            waypoint[4:] = delta_pos / delta_t
    else:
        waypoint[0] = 0.  # Timestamp
        position_coords = parsed_line.pop(0)
        if position_coords[0] is not None:
            waypoint[1] = position_coords[0]
        else:
            waypoint[1] = 0.
        if position_coords[1] is not None:
            waypoint[2] = position_coords[1]
        else:
            waypoint[2] = 0.
        if position_coords[2] is not None:
            waypoint[3] = position_coords[2]
        else:
            waypoint[3] = 0.
        waypoint[4], waypoint[5], waypoint[6] = 0., 0., 0.
    return waypoint

def gcode_to_waypoints(gcodeFileName):
    timestamped_waypoints = []

    gcode_lines = open(gcodeFileName, 'r').read().split('\n')
    while(gcode_lines):
        ### TODO: pop(0) is the most inefficient way to remove items
        ### TODO: Look up queues and deque functions
        current_gcode_line = gcode_lines.pop(0)
        current_parsed_line = parse_gcode_line(current_gcode_line)
        if current_parsed_line==None:
            continue
        else:
            move_type = current_parsed_line.pop(0)
            if move_type==0 or move_type==1:
                if timestamped_waypoints:
                    prev_waypoint = timestamped_waypoints[-1]
                else:
                    prev_waypoint = np.array([])
                waypoint = parsed_line_to_waypoint(current_parsed_line, prev_waypoint)
                timestamped_waypoints.append(waypoint)
    timestamped_waypoints = np.array(timestamped_waypoints)

    waypoint_dictionary = {}
    waypoint_dictionary['t'] = timestamped_waypoints[:,0]
    waypoint_dictionary['pos'] = timestamped_waypoints[:,1:4]
    waypoint_dictionary['vel'] = timestamped_waypoints[:,4:7]
    return waypoint_dictionary

def main():
    if len(sys.argv) < 2:
        sys.exit('Must provide gcode filename')
    fname = sys.argv[1]

    if not os.path.isfile(fname):
        sys.exit('gcode file does not exist')

    waypoint_dictionary = gcode_to_waypoints(fname)

    ### Save waypoints as a pickle file
    with open(fname[:-6]+"_waypoints.pickle", "wb") as pkl_handle:
	    pickle.dump(waypoint_dictionary, pkl_handle)

if __name__ == '__main__':
    main()
